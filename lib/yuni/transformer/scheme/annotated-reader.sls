(library (yuni transformer scheme annotated-reader)
         (export file->source)
         (import 
           (rnrs base)
           (rnrs mutable-strings)
           (rnrs control)
           (rnrs lists)
           (rnrs unicode)
           (rnrs bytevectors)
           (only (rnrs io ports) eof-object eof-object?)
           (only (rnrs io simple) read-char open-input-file)
           (yuni core)
           (yuni transformer scheme identifier-object))


(define locationStart 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; $Id$
;
; Reference implementation of R6RS get-datum.
;
; The scanner's state machine and the recursive descent parser
; were generated by Will Clinger's LexGen and ParseGen, so the
; parser can be extended or customized by regenerating those
; parts.
;
; LexGen and ParseGen are available at
; http://www.ccs.neu.edu/home/will/Research/SW2006/*.tar.gz
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; FIXME:
;
; This file contains several R6RS notations that could cause
; problems for cross-compilation:
;
; #\nul, #\backspace, #\tab, #\linefeed, #\vtab, and #\page.
;
; Larceny v0.93 and MzScheme v370 recognizes those notations.
;
; MzScheme v370 does not recognize #\alarm, #\esc, or #\delete,
; so they have been removed from this file.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; R6RS Scheme get-datum.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (file->source filename)

  (define null-input (list 'null))
  (define buf null-input)
  (define col 0)
  (define line 1)
  (define p (open-input-file filename))

  ; YUNI: current position
  (define current-position #f)
  (define (record-current-position!)
    (set! current-position (list filename line col)))

  ; YUNI: input and peek procedures
  (define (do-input) ;; do true input op
    (set! buf (read-char p))
    (cond
      ((char=? #\newline buf)
       (set! col 0)
       (set! line (+ 1 line)))
      (else
        (set! col (+ 1 col)))))
  (define (input)
    ;; (read-char port)
    (when (eq? buf null-input)
      (do-input))
    (let ((ret buf))
      (set! buf null-input)
      ret))
  (define (peek)
    ;; (peek-char port)
    (when (eq? buf null-input)
      (do-input))
    buf)

  ; Constants and local variables.

  (let* (; Constants.

         ; initial length of string_accumulator

         (initial_accumulator_length 64)

         ; Encodings of error messages.

         (errLongToken 1)                 ; extremely long token
         (errIncompleteToken 2)      ; any lexical error, really
         (errIllegalHexEscape 3)                 ; illegal \x...
         (errIllegalNamedChar 4)                 ; illegal #\...
         (errIllegalString 5)                   ; illegal string
         (errIllegalSymbol 6)                   ; illegal symbol
         (errNoDelimiter 7)      ; missing delimiter after token
         (errSquareBracket 8)     ; square bracket when disabled
         (errBug 9)            ; bug in reader, shouldn't happen
         (errLexGenBug 10)                        ; can't happen

         ; Named characters that MzScheme 370 doesn't recognize.

         (char:alarm  (integer->char 7))
         (char:esc    (integer->char 27))
         (char:delete (integer->char 127))

         ; Important but unnamed non-Ascii characters.

         (char:nel    (integer->char #x85))
         (char:ls     (integer->char #x2028))

         ; State for one-token buffering in lexical analyzer.

         (kindOfNextToken 'z1)      ; valid iff nextTokenIsReady
         (nextTokenIsReady #f)

         (tokenValue "")  ; string associated with current token

         ; A string buffer for the characters of the current token.
         ; Resized as necessary.

         (string_accumulator (make-string initial_accumulator_length))

         ; Number of characters in string_accumulator.

         (string_accumulator_length 0)

        )

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;
    ; Hand-coding scanner0 makes a small but worthwhile difference.
    ;
    ; The most common characters are spaces, parentheses, newlines,
    ; semicolons, and lower case Ascii letters.
    ;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
    ; Scanning for the start of a token.

    (define (scanner0)
      (define (loop c)
        (cond ((not (char? c))
               (accept 'eofobj))
              ((or (char=? c #\space)
                   (char=? c #\newline))
               (input)
               (loop (peek)))
              (else
                (record-current-position!)
                (state0 c))))
      (loop (peek)))

    ; Consuming a semicolon comment.

    (define (scanner1)
      (define (loop c)
        (cond ((not (char? c))
               (accept 'eofobj))
              ((char=? c #\newline)
               (scanner0))
              (else
               (loop (input)))))
      (loop (input)))
  
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;
    ; LexGen generated the code for the state machine.
    ;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
  (define (state0 c)
    (case c
      ((#\`) (consumeChar) (accept 'backquote))
      ((#\') (consumeChar) (accept 'quote))
      ((#\]) (consumeChar) (accept 'rbracket))
      ((#\[) (consumeChar) (accept 'lbracket))
      ((#\)) (consumeChar) (accept 'rparen))
      ((#\() (consumeChar) (accept 'lparen))
      ((#\tab #\newline #\vtab #\page #\return #\space)
       (consumeChar)
       (begin
         (set! string_accumulator_length 0)
         (state0 (scanChar))))
      ((#\;) (consumeChar) (state212 (scanChar)))
      ((#\#) (consumeChar) (state211 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state140 (scanChar)))
      ((#\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\g
        #\h
        #\i
        #\j
        #\k
        #\l
        #\m
        #\n
        #\o
        #\p
        #\q
        #\r
        #\s
        #\t
        #\u
        #\v
        #\w
        #\x
        #\y
        #\z
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F
        #\G
        #\H
        #\I
        #\J
        #\K
        #\L
        #\M
        #\N
        #\O
        #\P
        #\Q
        #\R
        #\S
        #\T
        #\U
        #\V
        #\W
        #\X
        #\Y
        #\Z
        #\!
        #\$
        #\%
        #\&
        #\*
        #\/
        #\:
        #\<
        #\=
        #\>
        #\?
        #\^
        #\_
        #\~)
       (consumeChar)
       (state13 (scanChar)))
      ((#\\) (consumeChar) (state12 (scanChar)))
      ((#\-) (consumeChar) (state9 (scanChar)))
      ((#\+) (consumeChar) (state8 (scanChar)))
      ((#\.) (consumeChar) (state7 (scanChar)))
      ((#\") (consumeChar) (state5 (scanChar)))
      ((#\,) (consumeChar) (state1 (scanChar)))
      (else
       (if ((lambda (c)
              (and (char? c)
                   (> (char->integer c) 127)
                   (let ((cat (char-general-category c)))
                     (memq cat
                           '(Lu Ll
                                Lt
                                Lm
                                Lo
                                Mn
                                Nl
                                No
                                Pd
                                Pc
                                Po
                                Sc
                                Sm
                                Sk
                                So
                                Co)))))
            c)
           (begin (consumeChar) (state13 (scanChar)))
           (if (eof-object? c)
               (begin (consumeChar) (accept 'eofobj))
               (if ((lambda (c) (and (char? c) (char-whitespace? c)))
                    c)
                   (begin
                     (consumeChar)
                     (begin
                       (set! string_accumulator_length 0)
                       (state0 (scanChar))))
                   (if ((lambda (c)
                          (and (char? c) (char=? c (integer->char 133))))
                        c)
                       (begin
                         (consumeChar)
                         (begin
                           (set! string_accumulator_length 0)
                           (state0 (scanChar))))
                       (scannerError errIncompleteToken))))))))
  (define (state1 c)
    (case c
      ((#\@) (consumeChar) (accept 'splicing))
      (else (accept 'comma))))
  (define (state2 c)
    (case c
      ((#\") (consumeChar) (accept 'string))
      ((#\newline #\return)
       (consumeChar)
       (state5 (scanChar)))
      ((#\\) (consumeChar) (state4 (scanChar)))
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state2 (scanChar)))
      (else
       (if (char? c)
           (begin (consumeChar) (state5 (scanChar)))
           (if ((lambda (c)
                  (and (char? c) (char=? c (integer->char 8232))))
                c)
               (begin (consumeChar) (state5 (scanChar)))
               (if ((lambda (c)
                      (and (char? c) (char=? c (integer->char 133))))
                    c)
                   (begin (consumeChar) (state5 (scanChar)))
                   (scannerError errIncompleteToken)))))))
  (define (state3 c)
    (case c
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state2 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state4 c)
    (case c
      ((#\a
        #\b
        #\t
        #\n
        #\v
        #\f
        #\r
        #\"
        #\\
        #\newline
        #\return
        #\space)
       (consumeChar)
       (state5 (scanChar)))
      ((#\x) (consumeChar) (state3 (scanChar)))
      (else
       (if ((lambda (c)
              (and (char? c) (char=? c (integer->char 8232))))
            c)
           (begin (consumeChar) (state5 (scanChar)))
           (if ((lambda (c)
                  (and (char? c) (char=? c (integer->char 133))))
                c)
               (begin (consumeChar) (state5 (scanChar)))
               (scannerError errIncompleteToken))))))
  (define (state5 c)
    (case c
      ((#\") (consumeChar) (accept 'string))
      ((#\newline #\return)
       (consumeChar)
       (state5 (scanChar)))
      ((#\\) (consumeChar) (state4 (scanChar)))
      (else
       (if (char? c)
           (begin (consumeChar) (state5 (scanChar)))
           (if ((lambda (c)
                  (and (char? c) (char=? c (integer->char 8232))))
                c)
               (begin (consumeChar) (state5 (scanChar)))
               (if ((lambda (c)
                      (and (char? c) (char=? c (integer->char 133))))
                    c)
                   (begin (consumeChar) (state5 (scanChar)))
                   (scannerError errIncompleteToken)))))))
  (define (state6 c)
    (case c
      ((#\.) (consumeChar) (accept 'id))
      (else (scannerError errIncompleteToken))))
  (define (state7 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state129 (scanChar)))
      ((#\.) (consumeChar) (state6 (scanChar)))
      (else (accept 'period))))
  (define (state8 c)
    (case c
      ((#\I) (consumeChar) (accept 'number))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state202 (scanChar)))
      ((#\.) (consumeChar) (state148 (scanChar)))
      ((#\n) (consumeChar) (state147 (scanChar)))
      ((#\i) (consumeChar) (state142 (scanChar)))
      (else (accept 'id))))
  (define (state9 c)
    (case c
      ((#\I) (consumeChar) (accept 'number))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state202 (scanChar)))
      ((#\.) (consumeChar) (state148 (scanChar)))
      ((#\n) (consumeChar) (state147 (scanChar)))
      ((#\i) (consumeChar) (state142 (scanChar)))
      ((#\>) (consumeChar) (state13 (scanChar)))
      (else (accept 'id))))
  (define (state10 c)
    (case c
      ((#\;) (consumeChar) (state13 (scanChar)))
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state10 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state11 c)
    (case c
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state10 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state12 c)
    (case c
      ((#\x) (consumeChar) (state11 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state13 c)
    (case c
      ((#\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\g
        #\h
        #\i
        #\j
        #\k
        #\l
        #\m
        #\n
        #\o
        #\p
        #\q
        #\r
        #\s
        #\t
        #\u
        #\v
        #\w
        #\x
        #\y
        #\z
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F
        #\G
        #\H
        #\I
        #\J
        #\K
        #\L
        #\M
        #\N
        #\O
        #\P
        #\Q
        #\R
        #\S
        #\T
        #\U
        #\V
        #\W
        #\X
        #\Y
        #\Z
        #\!
        #\$
        #\%
        #\&
        #\*
        #\/
        #\:
        #\<
        #\=
        #\>
        #\?
        #\^
        #\_
        #\~
        #\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\+
        #\-
        #\.
        #\@)
       (consumeChar)
       (state13 (scanChar)))
      ((#\\) (consumeChar) (state12 (scanChar)))
      (else
       (if ((lambda (c)
              (and (char? c)
                   (let ((cat (char-general-category c)))
                     (memq cat '(Nd Mc Me)))))
            c)
           (begin (consumeChar) (state13 (scanChar)))
           (if ((lambda (c)
                  (and (char? c)
                       (> (char->integer c) 127)
                       (let ((cat (char-general-category c)))
                         (memq cat
                               '(Lu Ll
                                    Lt
                                    Lm
                                    Lo
                                    Mn
                                    Nl
                                    No
                                    Pd
                                    Pc
                                    Po
                                    Sc
                                    Sm
                                    Sk
                                    So
                                    Co)))))
                c)
               (begin (consumeChar) (state13 (scanChar)))
               (accept 'id))))))
  (define (state14 c)
    (case c
      ((#\@) (consumeChar) (accept 'unsyntaxsplicing))
      (else (accept 'unsyntax))))
  (define (state15 c)
    (case c
      ((#\() (consumeChar) (accept 'bvecstart))
      (else (scannerError errIncompleteToken))))
  (define (state16 c)
    (case c
      ((#\8) (consumeChar) (state15 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state17 c)
    (case c
      ((#\u) (consumeChar) (state16 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state18 c)
    (case c
      ((#\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\g
        #\h
        #\i
        #\j
        #\k
        #\l
        #\m
        #\n
        #\o
        #\p
        #\q
        #\r
        #\s
        #\t
        #\u
        #\v
        #\w
        #\x
        #\y
        #\z
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F
        #\G
        #\H
        #\I
        #\J
        #\K
        #\L
        #\M
        #\N
        #\O
        #\P
        #\Q
        #\R
        #\S
        #\T
        #\U
        #\V
        #\W
        #\X
        #\Y
        #\Z)
       (consumeChar)
       (state18 (scanChar)))
      (else (accept 'character))))
  (define (state19 c)
    (case c
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state19 (scanChar)))
      (else (accept 'character))))
  (define (state20 c)
    (case c
      ((#\a #\b #\c #\d #\e #\f #\A #\B #\C #\D #\E #\F)
       (consumeChar)
       (state20 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state19 (scanChar)))
      ((#\g
        #\h
        #\i
        #\j
        #\k
        #\l
        #\m
        #\n
        #\o
        #\p
        #\q
        #\r
        #\s
        #\t
        #\u
        #\v
        #\w
        #\x
        #\y
        #\z
        #\G
        #\H
        #\I
        #\J
        #\K
        #\L
        #\M
        #\N
        #\O
        #\P
        #\Q
        #\R
        #\S
        #\T
        #\U
        #\V
        #\W
        #\X
        #\Y
        #\Z)
       (consumeChar)
       (state18 (scanChar)))
      (else (accept 'character))))
  (define (state21 c)
    (case c
      ((#\x) (consumeChar) (state20 (scanChar)))
      ((#\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\g
        #\h
        #\i
        #\j
        #\k
        #\l
        #\m
        #\n
        #\o
        #\p
        #\q
        #\r
        #\s
        #\t
        #\u
        #\v
        #\w
        #\y
        #\z
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F
        #\G
        #\H
        #\I
        #\J
        #\K
        #\L
        #\M
        #\N
        #\O
        #\P
        #\Q
        #\R
        #\S
        #\T
        #\U
        #\V
        #\W
        #\X
        #\Y
        #\Z)
       (consumeChar)
       (state18 (scanChar)))
      (else
       (if (char? c)
           (begin (consumeChar) (accept 'character))
           (scannerError errIncompleteToken)))))
  (define (state22 c)
    (case c
      ((#\i #\I #\e #\E)
       (consumeChar)
       (state57 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state23 c)
    (case c
      ((#\+ #\-) (consumeChar) (state56 (scanChar)))
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state32 (scanChar)))
      ((#\#) (consumeChar) (state22 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state24 c)
    (case c
      ((#\i #\I #\e #\E)
       (consumeChar)
       (state87 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state25 c)
    (case c
      ((#\+ #\-) (consumeChar) (state86 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state62 (scanChar)))
      ((#\#) (consumeChar) (state24 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state26 c)
    (case c
      ((#\i #\I #\e #\E)
       (consumeChar)
       (state125 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state27 c)
    (case c
      ((#\+ #\-) (consumeChar) (state124 (scanChar)))
      ((#\0 #\1) (consumeChar) (state92 (scanChar)))
      ((#\#) (consumeChar) (state26 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state28 c)
    (case c
      ((#\@) (consumeChar) (state50 (scanChar)))
      ((#\+ #\-) (consumeChar) (state44 (scanChar)))
      ((#\#) (consumeChar) (state28 (scanChar)))
      (else (accept 'number))))
  (define (state29 c)
    (case c
      ((#\@) (consumeChar) (state50 (scanChar)))
      ((#\+ #\-) (consumeChar) (state44 (scanChar)))
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state29 (scanChar)))
      ((#\#) (consumeChar) (state28 (scanChar)))
      (else (accept 'number))))
  (define (state30 c)
    (case c
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state29 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state31 c)
    (case c
      ((#\@) (consumeChar) (state50 (scanChar)))
      ((#\+ #\-) (consumeChar) (state44 (scanChar)))
      ((#\#) (consumeChar) (state31 (scanChar)))
      ((#\/) (consumeChar) (state30 (scanChar)))
      (else (accept 'number))))
  (define (state32 c)
    (case c
      ((#\@) (consumeChar) (state50 (scanChar)))
      ((#\+ #\-) (consumeChar) (state44 (scanChar)))
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state32 (scanChar)))
      ((#\#) (consumeChar) (state31 (scanChar)))
      ((#\/) (consumeChar) (state30 (scanChar)))
      (else (accept 'number))))
  (define (state33 c)
    (case c
      ((#\f) (consumeChar) (state37 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state34 c)
    (case c
      ((#\n) (consumeChar) (state33 (scanChar)))
      (else (accept 'number))))
  (define (state35 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\@) (consumeChar) (state50 (scanChar)))
      ((#\+ #\-) (consumeChar) (state44 (scanChar)))
      (else (accept 'number))))
  (define (state36 c)
    (case c
      ((#\0) (consumeChar) (state35 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state37 c)
    (case c
      ((#\.) (consumeChar) (state36 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state38 c)
    (case c
      ((#\n) (consumeChar) (state37 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state39 c)
    (case c
      ((#\a) (consumeChar) (state38 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state40 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state107 (scanChar)))
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state40 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state41 c)
    (case c
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state40 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state42 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state42 (scanChar)))
      ((#\/) (consumeChar) (state41 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state43 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state43 (scanChar)))
      ((#\#) (consumeChar) (state42 (scanChar)))
      ((#\/) (consumeChar) (state41 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state44 c)
    (case c
      ((#\n) (consumeChar) (state106 (scanChar)))
      ((#\i) (consumeChar) (state101 (scanChar)))
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state43 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state45 c)
    (case c
      ((#\#) (consumeChar) (state191 (scanChar)))
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state45 (scanChar)))
      (else (accept 'number))))
  (define (state46 c)
    (case c
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state45 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state47 c)
    (case c
      ((#\#) (consumeChar) (state47 (scanChar)))
      ((#\/) (consumeChar) (state46 (scanChar)))
      (else (accept 'number))))
  (define (state48 c)
    (case c
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state48 (scanChar)))
      ((#\#) (consumeChar) (state47 (scanChar)))
      ((#\/) (consumeChar) (state46 (scanChar)))
      (else (accept 'number))))
  (define (state49 c)
    (case c
      ((#\n) (consumeChar) (state182 (scanChar)))
      ((#\i) (consumeChar) (state178 (scanChar)))
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state48 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state50 c)
    (case c
      ((#\+ #\-) (consumeChar) (state49 (scanChar)))
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state48 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state51 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state51 (scanChar)))
      ((#\@) (consumeChar) (state50 (scanChar)))
      ((#\+ #\-) (consumeChar) (state44 (scanChar)))
      (else (accept 'number))))
  (define (state52 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state52 (scanChar)))
      ((#\#) (consumeChar) (state51 (scanChar)))
      ((#\@) (consumeChar) (state50 (scanChar)))
      ((#\+ #\-) (consumeChar) (state44 (scanChar)))
      (else (accept 'number))))
  (define (state53 c)
    (case c
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state52 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state54 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state54 (scanChar)))
      ((#\/) (consumeChar) (state53 (scanChar)))
      ((#\@) (consumeChar) (state50 (scanChar)))
      ((#\+ #\-) (consumeChar) (state44 (scanChar)))
      (else (accept 'number))))
  (define (state55 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state55 (scanChar)))
      ((#\#) (consumeChar) (state54 (scanChar)))
      ((#\/) (consumeChar) (state53 (scanChar)))
      ((#\@) (consumeChar) (state50 (scanChar)))
      ((#\+ #\-) (consumeChar) (state44 (scanChar)))
      (else (accept 'number))))
  (define (state56 c)
    (case c
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state55 (scanChar)))
      ((#\n) (consumeChar) (state39 (scanChar)))
      ((#\i) (consumeChar) (state34 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state57 c)
    (case c
      ((#\+ #\-) (consumeChar) (state56 (scanChar)))
      ((#\0
        #\1
        #\2
        #\3
        #\4
        #\5
        #\6
        #\7
        #\8
        #\9
        #\a
        #\b
        #\c
        #\d
        #\e
        #\f
        #\A
        #\B
        #\C
        #\D
        #\E
        #\F)
       (consumeChar)
       (state32 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state58 c)
    (case c
      ((#\@) (consumeChar) (state80 (scanChar)))
      ((#\+ #\-) (consumeChar) (state74 (scanChar)))
      ((#\#) (consumeChar) (state58 (scanChar)))
      (else (accept 'number))))
  (define (state59 c)
    (case c
      ((#\@) (consumeChar) (state80 (scanChar)))
      ((#\+ #\-) (consumeChar) (state74 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state59 (scanChar)))
      ((#\#) (consumeChar) (state58 (scanChar)))
      (else (accept 'number))))
  (define (state60 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state59 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state61 c)
    (case c
      ((#\@) (consumeChar) (state80 (scanChar)))
      ((#\+ #\-) (consumeChar) (state74 (scanChar)))
      ((#\#) (consumeChar) (state61 (scanChar)))
      ((#\/) (consumeChar) (state60 (scanChar)))
      (else (accept 'number))))
  (define (state62 c)
    (case c
      ((#\@) (consumeChar) (state80 (scanChar)))
      ((#\+ #\-) (consumeChar) (state74 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state62 (scanChar)))
      ((#\#) (consumeChar) (state61 (scanChar)))
      ((#\/) (consumeChar) (state60 (scanChar)))
      (else (accept 'number))))
  (define (state63 c)
    (case c
      ((#\f) (consumeChar) (state67 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state64 c)
    (case c
      ((#\n) (consumeChar) (state63 (scanChar)))
      (else (accept 'number))))
  (define (state65 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\@) (consumeChar) (state80 (scanChar)))
      ((#\+ #\-) (consumeChar) (state74 (scanChar)))
      (else (accept 'number))))
  (define (state66 c)
    (case c
      ((#\0) (consumeChar) (state65 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state67 c)
    (case c
      ((#\.) (consumeChar) (state66 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state68 c)
    (case c
      ((#\n) (consumeChar) (state67 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state69 c)
    (case c
      ((#\a) (consumeChar) (state68 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state70 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state107 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state70 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state71 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state70 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state72 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state72 (scanChar)))
      ((#\/) (consumeChar) (state71 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state73 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state73 (scanChar)))
      ((#\#) (consumeChar) (state72 (scanChar)))
      ((#\/) (consumeChar) (state71 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state74 c)
    (case c
      ((#\n) (consumeChar) (state106 (scanChar)))
      ((#\i) (consumeChar) (state101 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state73 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state75 c)
    (case c
      ((#\#) (consumeChar) (state191 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state75 (scanChar)))
      (else (accept 'number))))
  (define (state76 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state75 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state77 c)
    (case c
      ((#\#) (consumeChar) (state77 (scanChar)))
      ((#\/) (consumeChar) (state76 (scanChar)))
      (else (accept 'number))))
  (define (state78 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state78 (scanChar)))
      ((#\#) (consumeChar) (state77 (scanChar)))
      ((#\/) (consumeChar) (state76 (scanChar)))
      (else (accept 'number))))
  (define (state79 c)
    (case c
      ((#\n) (consumeChar) (state182 (scanChar)))
      ((#\i) (consumeChar) (state178 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state78 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state80 c)
    (case c
      ((#\+ #\-) (consumeChar) (state79 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state78 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state81 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state81 (scanChar)))
      ((#\@) (consumeChar) (state80 (scanChar)))
      ((#\+ #\-) (consumeChar) (state74 (scanChar)))
      (else (accept 'number))))
  (define (state82 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state82 (scanChar)))
      ((#\#) (consumeChar) (state81 (scanChar)))
      ((#\@) (consumeChar) (state80 (scanChar)))
      ((#\+ #\-) (consumeChar) (state74 (scanChar)))
      (else (accept 'number))))
  (define (state83 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state82 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state84 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state84 (scanChar)))
      ((#\/) (consumeChar) (state83 (scanChar)))
      ((#\@) (consumeChar) (state80 (scanChar)))
      ((#\+ #\-) (consumeChar) (state74 (scanChar)))
      (else (accept 'number))))
  (define (state85 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state85 (scanChar)))
      ((#\#) (consumeChar) (state84 (scanChar)))
      ((#\/) (consumeChar) (state83 (scanChar)))
      ((#\@) (consumeChar) (state80 (scanChar)))
      ((#\+ #\-) (consumeChar) (state74 (scanChar)))
      (else (accept 'number))))
  (define (state86 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state85 (scanChar)))
      ((#\n) (consumeChar) (state69 (scanChar)))
      ((#\i) (consumeChar) (state64 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state87 c)
    (case c
      ((#\+ #\-) (consumeChar) (state86 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7)
       (consumeChar)
       (state62 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state88 c)
    (case c
      ((#\@) (consumeChar) (state118 (scanChar)))
      ((#\+ #\-) (consumeChar) (state112 (scanChar)))
      ((#\#) (consumeChar) (state88 (scanChar)))
      (else (accept 'number))))
  (define (state89 c)
    (case c
      ((#\@) (consumeChar) (state118 (scanChar)))
      ((#\+ #\-) (consumeChar) (state112 (scanChar)))
      ((#\0 #\1) (consumeChar) (state89 (scanChar)))
      ((#\#) (consumeChar) (state88 (scanChar)))
      (else (accept 'number))))
  (define (state90 c)
    (case c
      ((#\0 #\1) (consumeChar) (state89 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state91 c)
    (case c
      ((#\@) (consumeChar) (state118 (scanChar)))
      ((#\+ #\-) (consumeChar) (state112 (scanChar)))
      ((#\#) (consumeChar) (state91 (scanChar)))
      ((#\/) (consumeChar) (state90 (scanChar)))
      (else (accept 'number))))
  (define (state92 c)
    (case c
      ((#\@) (consumeChar) (state118 (scanChar)))
      ((#\+ #\-) (consumeChar) (state112 (scanChar)))
      ((#\0 #\1) (consumeChar) (state92 (scanChar)))
      ((#\#) (consumeChar) (state91 (scanChar)))
      ((#\/) (consumeChar) (state90 (scanChar)))
      (else (accept 'number))))
  (define (state93 c)
    (case c
      ((#\f) (consumeChar) (state97 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state94 c)
    (case c
      ((#\n) (consumeChar) (state93 (scanChar)))
      (else (accept 'number))))
  (define (state95 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\@) (consumeChar) (state118 (scanChar)))
      ((#\+ #\-) (consumeChar) (state112 (scanChar)))
      (else (accept 'number))))
  (define (state96 c)
    (case c
      ((#\0) (consumeChar) (state95 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state97 c)
    (case c
      ((#\.) (consumeChar) (state96 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state98 c)
    (case c
      ((#\n) (consumeChar) (state97 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state99 c)
    (case c
      ((#\a) (consumeChar) (state98 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state100 c)
    (case c
      ((#\f) (consumeChar) (state104 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state101 c)
    (case c
      ((#\n) (consumeChar) (state100 (scanChar)))
      (else (accept 'number))))
  (define (state102 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      (else (scannerError errIncompleteToken))))
  (define (state103 c)
    (case c
      ((#\0) (consumeChar) (state102 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state104 c)
    (case c
      ((#\.) (consumeChar) (state103 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state105 c)
    (case c
      ((#\n) (consumeChar) (state104 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state106 c)
    (case c
      ((#\a) (consumeChar) (state105 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state107 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state107 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state108 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\0 #\1) (consumeChar) (state108 (scanChar)))
      ((#\#) (consumeChar) (state107 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state109 c)
    (case c
      ((#\0 #\1) (consumeChar) (state108 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state110 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state110 (scanChar)))
      ((#\/) (consumeChar) (state109 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state111 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\0 #\1) (consumeChar) (state111 (scanChar)))
      ((#\#) (consumeChar) (state110 (scanChar)))
      ((#\/) (consumeChar) (state109 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state112 c)
    (case c
      ((#\0 #\1) (consumeChar) (state111 (scanChar)))
      ((#\n) (consumeChar) (state106 (scanChar)))
      ((#\i) (consumeChar) (state101 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state113 c)
    (case c
      ((#\#) (consumeChar) (state191 (scanChar)))
      ((#\0 #\1) (consumeChar) (state113 (scanChar)))
      (else (accept 'number))))
  (define (state114 c)
    (case c
      ((#\0 #\1) (consumeChar) (state113 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state115 c)
    (case c
      ((#\#) (consumeChar) (state115 (scanChar)))
      ((#\/) (consumeChar) (state114 (scanChar)))
      (else (accept 'number))))
  (define (state116 c)
    (case c
      ((#\0 #\1) (consumeChar) (state116 (scanChar)))
      ((#\#) (consumeChar) (state115 (scanChar)))
      ((#\/) (consumeChar) (state114 (scanChar)))
      (else (accept 'number))))
  (define (state117 c)
    (case c
      ((#\n) (consumeChar) (state182 (scanChar)))
      ((#\i) (consumeChar) (state178 (scanChar)))
      ((#\0 #\1) (consumeChar) (state116 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state118 c)
    (case c
      ((#\+ #\-) (consumeChar) (state117 (scanChar)))
      ((#\0 #\1) (consumeChar) (state116 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state119 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state119 (scanChar)))
      ((#\@) (consumeChar) (state118 (scanChar)))
      ((#\+ #\-) (consumeChar) (state112 (scanChar)))
      (else (accept 'number))))
  (define (state120 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\0 #\1) (consumeChar) (state120 (scanChar)))
      ((#\#) (consumeChar) (state119 (scanChar)))
      ((#\@) (consumeChar) (state118 (scanChar)))
      ((#\+ #\-) (consumeChar) (state112 (scanChar)))
      (else (accept 'number))))
  (define (state121 c)
    (case c
      ((#\0 #\1) (consumeChar) (state120 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state122 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state122 (scanChar)))
      ((#\/) (consumeChar) (state121 (scanChar)))
      ((#\@) (consumeChar) (state118 (scanChar)))
      ((#\+ #\-) (consumeChar) (state112 (scanChar)))
      (else (accept 'number))))
  (define (state123 c)
    (case c
      ((#\i) (consumeChar) (accept 'number))
      ((#\0 #\1) (consumeChar) (state123 (scanChar)))
      ((#\#) (consumeChar) (state122 (scanChar)))
      ((#\/) (consumeChar) (state121 (scanChar)))
      ((#\@) (consumeChar) (state118 (scanChar)))
      ((#\+ #\-) (consumeChar) (state112 (scanChar)))
      (else (accept 'number))))
  (define (state124 c)
    (case c
      ((#\0 #\1) (consumeChar) (state123 (scanChar)))
      ((#\n) (consumeChar) (state99 (scanChar)))
      ((#\i) (consumeChar) (state94 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state125 c)
    (case c
      ((#\+ #\-) (consumeChar) (state124 (scanChar)))
      ((#\0 #\1) (consumeChar) (state92 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state126 c)
    (case c
      ((#\d #\D) (consumeChar) (state204 (scanChar)))
      ((#\b #\B) (consumeChar) (state125 (scanChar)))
      ((#\o #\O) (consumeChar) (state87 (scanChar)))
      ((#\x #\X) (consumeChar) (state57 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state127 c)
    (case c
      ((#\+ #\-) (consumeChar) (state203 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state140 (scanChar)))
      ((#\.) (consumeChar) (state128 (scanChar)))
      ((#\#) (consumeChar) (state126 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state128 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state129 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state129 c)
    (case c
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      ((#\#) (consumeChar) (state135 (scanChar)))
      ((#\e #\E #\s #\S #\f #\F #\d #\D #\l #\L)
       (consumeChar)
       (state134 (scanChar)))
      ((#\|) (consumeChar) (state131 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state129 (scanChar)))
      (else (accept 'number))))
  (define (state130 c)
    (case c
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state130 (scanChar)))
      (else (accept 'number))))
  (define (state131 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state130 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state132 c)
    (case c
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state132 (scanChar)))
      ((#\|) (consumeChar) (state131 (scanChar)))
      (else (accept 'number))))
  (define (state133 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state132 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state134 c)
    (case c
      ((#\+ #\-) (consumeChar) (state133 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state132 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state135 c)
    (case c
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      ((#\#) (consumeChar) (state135 (scanChar)))
      ((#\e #\E #\s #\S #\f #\F #\d #\D #\l #\L)
       (consumeChar)
       (state134 (scanChar)))
      ((#\|) (consumeChar) (state131 (scanChar)))
      (else (accept 'number))))
  (define (state136 c)
    (case c
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      ((#\#) (consumeChar) (state136 (scanChar)))
      (else (accept 'number))))
  (define (state137 c)
    (case c
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state137 (scanChar)))
      ((#\#) (consumeChar) (state136 (scanChar)))
      (else (accept 'number))))
  (define (state138 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state137 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state139 c)
    (case c
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      ((#\#) (consumeChar) (state139 (scanChar)))
      ((#\/) (consumeChar) (state138 (scanChar)))
      ((#\.) (consumeChar) (state135 (scanChar)))
      ((#\e #\E #\s #\S #\f #\F #\d #\D #\l #\L)
       (consumeChar)
       (state134 (scanChar)))
      ((#\|) (consumeChar) (state131 (scanChar)))
      (else (accept 'number))))
  (define (state140 c)
    (case c
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state140 (scanChar)))
      ((#\#) (consumeChar) (state139 (scanChar)))
      ((#\/) (consumeChar) (state138 (scanChar)))
      ((#\e #\E #\s #\S #\f #\F #\d #\D #\l #\L)
       (consumeChar)
       (state134 (scanChar)))
      ((#\|) (consumeChar) (state131 (scanChar)))
      ((#\.) (consumeChar) (state129 (scanChar)))
      (else (accept 'number))))
  (define (state141 c)
    (case c
      ((#\f) (consumeChar) (state145 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state142 c)
    (case c
      ((#\n) (consumeChar) (state141 (scanChar)))
      (else (accept 'number))))
  (define (state143 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      (else (accept 'number))))
  (define (state144 c)
    (case c
      ((#\0) (consumeChar) (state143 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state145 c)
    (case c
      ((#\.) (consumeChar) (state144 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state146 c)
    (case c
      ((#\n) (consumeChar) (state145 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state147 c)
    (case c
      ((#\a) (consumeChar) (state146 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state148 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state149 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state149 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      ((#\#) (consumeChar) (state155 (scanChar)))
      ((#\e #\E #\s #\S #\f #\F #\d #\D #\l #\L)
       (consumeChar)
       (state154 (scanChar)))
      ((#\|) (consumeChar) (state151 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state149 (scanChar)))
      (else (accept 'number))))
  (define (state150 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state150 (scanChar)))
      (else (accept 'number))))
  (define (state151 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state150 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state152 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state152 (scanChar)))
      ((#\|) (consumeChar) (state151 (scanChar)))
      (else (accept 'number))))
  (define (state153 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state152 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state154 c)
    (case c
      ((#\+ #\-) (consumeChar) (state153 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state152 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state155 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      ((#\#) (consumeChar) (state155 (scanChar)))
      ((#\e #\E #\s #\S #\f #\F #\d #\D #\l #\L)
       (consumeChar)
       (state154 (scanChar)))
      ((#\|) (consumeChar) (state151 (scanChar)))
      (else (accept 'number))))
  (define (state156 c)
    (case c
      ((#\f) (consumeChar) (state160 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state157 c)
    (case c
      ((#\n) (consumeChar) (state156 (scanChar)))
      (else (accept 'number))))
  (define (state158 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      (else (scannerError errIncompleteToken))))
  (define (state159 c)
    (case c
      ((#\0) (consumeChar) (state158 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state160 c)
    (case c
      ((#\.) (consumeChar) (state159 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state161 c)
    (case c
      ((#\n) (consumeChar) (state160 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state162 c)
    (case c
      ((#\a) (consumeChar) (state161 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state163 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state164 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state164 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state170 (scanChar)))
      ((#\e #\E #\s #\S #\f #\F #\d #\D #\l #\L)
       (consumeChar)
       (state169 (scanChar)))
      ((#\|) (consumeChar) (state166 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state164 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state165 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state165 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state166 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state165 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state167 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state167 (scanChar)))
      ((#\|) (consumeChar) (state166 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state168 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state167 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state169 c)
    (case c
      ((#\+ #\-) (consumeChar) (state168 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state167 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state170 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state170 (scanChar)))
      ((#\e #\E #\s #\S #\f #\F #\d #\D #\l #\L)
       (consumeChar)
       (state169 (scanChar)))
      ((#\|) (consumeChar) (state166 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state171 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state171 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state172 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state172 (scanChar)))
      ((#\#) (consumeChar) (state171 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state173 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state172 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state174 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state174 (scanChar)))
      ((#\/) (consumeChar) (state173 (scanChar)))
      ((#\.) (consumeChar) (state170 (scanChar)))
      ((#\e #\E #\s #\S #\f #\F #\d #\D #\l #\L)
       (consumeChar)
       (state169 (scanChar)))
      ((#\|) (consumeChar) (state166 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state175 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state175 (scanChar)))
      ((#\#) (consumeChar) (state174 (scanChar)))
      ((#\/) (consumeChar) (state173 (scanChar)))
      ((#\e #\E #\s #\S #\f #\F #\d #\D #\l #\L)
       (consumeChar)
       (state169 (scanChar)))
      ((#\|) (consumeChar) (state166 (scanChar)))
      ((#\.) (consumeChar) (state164 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state176 c)
    (case c
      ((#\I) (consumeChar) (accept 'number))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state175 (scanChar)))
      ((#\.) (consumeChar) (state163 (scanChar)))
      ((#\n) (consumeChar) (state162 (scanChar)))
      ((#\i) (consumeChar) (state157 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state177 c)
    (case c
      ((#\f) (consumeChar) (state180 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state178 c)
    (case c
      ((#\n) (consumeChar) (state177 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state179 c)
    (case c
      ((#\0) (consumeChar) (accept 'number))
      (else (scannerError errIncompleteToken))))
  (define (state180 c)
    (case c
      ((#\.) (consumeChar) (state179 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state181 c)
    (case c
      ((#\n) (consumeChar) (state180 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state182 c)
    (case c
      ((#\a) (consumeChar) (state181 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state183 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state184 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state184 c)
    (case c
      ((#\#) (consumeChar) (state190 (scanChar)))
      ((#\e #\E #\s #\S #\f #\F #\d #\D #\l #\L)
       (consumeChar)
       (state189 (scanChar)))
      ((#\|) (consumeChar) (state186 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state184 (scanChar)))
      (else (accept 'number))))
  (define (state185 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state185 (scanChar)))
      (else (accept 'number))))
  (define (state186 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state185 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state187 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state187 (scanChar)))
      ((#\|) (consumeChar) (state186 (scanChar)))
      (else (accept 'number))))
  (define (state188 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state187 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state189 c)
    (case c
      ((#\+ #\-) (consumeChar) (state188 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state187 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state190 c)
    (case c
      ((#\#) (consumeChar) (state190 (scanChar)))
      ((#\e #\E #\s #\S #\f #\F #\d #\D #\l #\L)
       (consumeChar)
       (state189 (scanChar)))
      ((#\|) (consumeChar) (state186 (scanChar)))
      (else (accept 'number))))
  (define (state191 c)
    (case c
      ((#\#) (consumeChar) (state191 (scanChar)))
      (else (accept 'number))))
  (define (state192 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state192 (scanChar)))
      ((#\#) (consumeChar) (state191 (scanChar)))
      (else (accept 'number))))
  (define (state193 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state192 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state194 c)
    (case c
      ((#\#) (consumeChar) (state194 (scanChar)))
      ((#\/) (consumeChar) (state193 (scanChar)))
      ((#\.) (consumeChar) (state190 (scanChar)))
      ((#\e #\E #\s #\S #\f #\F #\d #\D #\l #\L)
       (consumeChar)
       (state189 (scanChar)))
      ((#\|) (consumeChar) (state186 (scanChar)))
      (else (accept 'number))))
  (define (state195 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state195 (scanChar)))
      ((#\#) (consumeChar) (state194 (scanChar)))
      ((#\/) (consumeChar) (state193 (scanChar)))
      ((#\e #\E #\s #\S #\f #\F #\d #\D #\l #\L)
       (consumeChar)
       (state189 (scanChar)))
      ((#\|) (consumeChar) (state186 (scanChar)))
      ((#\.) (consumeChar) (state184 (scanChar)))
      (else (accept 'number))))
  (define (state196 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state195 (scanChar)))
      ((#\.) (consumeChar) (state183 (scanChar)))
      ((#\n) (consumeChar) (state182 (scanChar)))
      ((#\i) (consumeChar) (state178 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state197 c)
    (case c
      ((#\+ #\-) (consumeChar) (state196 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state195 (scanChar)))
      ((#\.) (consumeChar) (state183 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state198 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state198 (scanChar)))
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      (else (accept 'number))))
  (define (state199 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state199 (scanChar)))
      ((#\#) (consumeChar) (state198 (scanChar)))
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      (else (accept 'number))))
  (define (state200 c)
    (case c
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state199 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state201 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\#) (consumeChar) (state201 (scanChar)))
      ((#\/) (consumeChar) (state200 (scanChar)))
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      ((#\.) (consumeChar) (state155 (scanChar)))
      ((#\e #\E #\s #\S #\f #\F #\d #\D #\l #\L)
       (consumeChar)
       (state154 (scanChar)))
      ((#\|) (consumeChar) (state151 (scanChar)))
      (else (accept 'number))))
  (define (state202 c)
    (case c
      ((#\i #\I) (consumeChar) (accept 'number))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state202 (scanChar)))
      ((#\#) (consumeChar) (state201 (scanChar)))
      ((#\/) (consumeChar) (state200 (scanChar)))
      ((#\@) (consumeChar) (state197 (scanChar)))
      ((#\+ #\-) (consumeChar) (state176 (scanChar)))
      ((#\e #\E #\s #\S #\f #\F #\d #\D #\l #\L)
       (consumeChar)
       (state154 (scanChar)))
      ((#\|) (consumeChar) (state151 (scanChar)))
      ((#\.) (consumeChar) (state149 (scanChar)))
      (else (accept 'number))))
  (define (state203 c)
    (case c
      ((#\I) (consumeChar) (accept 'number))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state202 (scanChar)))
      ((#\.) (consumeChar) (state148 (scanChar)))
      ((#\n) (consumeChar) (state147 (scanChar)))
      ((#\i) (consumeChar) (state142 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state204 c)
    (case c
      ((#\+ #\-) (consumeChar) (state203 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state140 (scanChar)))
      ((#\.) (consumeChar) (state128 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state205 c)
    (case c
      ((#\i #\I #\e #\E)
       (consumeChar)
       (state204 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state206 c)
    (case c
      ((#\#) (consumeChar) (state205 (scanChar)))
      ((#\+ #\-) (consumeChar) (state203 (scanChar)))
      ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
       (consumeChar)
       (state140 (scanChar)))
      ((#\.) (consumeChar) (state128 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state207 c)
    (case c
      ((#\s) (consumeChar) (accept 'miscflag))
      (else (scannerError errIncompleteToken))))
  (define (state208 c)
    (case c
      ((#\r) (consumeChar) (state207 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state209 c)
    (case c
      ((#\6) (consumeChar) (state208 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state210 c)
    (case c
      ((#\r) (consumeChar) (state209 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state211 c)
    (case c
      ((#\`) (consumeChar) (accept 'quasisyntax))
      ((#\') (consumeChar) (accept 'syntax))
      ((#\() (consumeChar) (accept 'vecstart))
      ((#\t #\T #\f #\F)
       (consumeChar)
       (accept 'boolean))
      ((#\;) (consumeChar) (accept 'commentdatum))
      ((#\|) (consumeChar) (accept 'comment))
      ((#\!) (consumeChar) (state210 (scanChar)))
      ((#\d #\D) (consumeChar) (state206 (scanChar)))
      ((#\i #\I #\e #\E)
       (consumeChar)
       (state127 (scanChar)))
      ((#\b #\B) (consumeChar) (state27 (scanChar)))
      ((#\o #\O) (consumeChar) (state25 (scanChar)))
      ((#\x #\X) (consumeChar) (state23 (scanChar)))
      ((#\\) (consumeChar) (state21 (scanChar)))
      ((#\v) (consumeChar) (state17 (scanChar)))
      ((#\,) (consumeChar) (state14 (scanChar)))
      (else (scannerError errIncompleteToken))))
  (define (state212 c)
    (case c
      (else
       (if ((lambda (c)
              (and (char? c)
                   (not (char=? c (integer->char 10)))))
            c)
           (begin (consumeChar) (state212 (scanChar)))
           (begin
             (set! string_accumulator_length 0)
             (state0 (scanChar)))))))
  (define (state213 c)
    (case c
      (else
       (begin
         (set! string_accumulator_length 0)
         (state0 (scanChar))))))
  (define (state214 c)
    (case c (else (accept 'comment))))
  (define (state215 c)
    (case c (else (accept 'commentdatum))))
  (define (state216 c)
    (case c (else (accept 'miscflag))))
  (define (state217 c)
    (case c (else (accept 'boolean))))
  (define (state218 c)
    (case c (else (accept 'number))))
  (define (state219 c)
    (case c (else (accept 'character))))
  (define (state220 c)
    (case c (else (accept 'vecstart))))
  (define (state221 c)
    (case c (else (accept 'bvecstart))))
  (define (state222 c)
    (case c (else (accept 'syntax))))
  (define (state223 c)
    (case c (else (accept 'quasisyntax))))
  (define (state224 c)
    (case c (else (accept 'unsyntaxsplicing))))
  (define (state225 c)
    (case c (else (accept 'eofobj))))
  (define (state226 c)
    (case c (else (accept 'id))))
  (define (state227 c)
    (case c (else (accept 'string))))
  (define (state228 c)
    (case c (else (accept 'lparen))))
  (define (state229 c)
    (case c (else (accept 'rparen))))
  (define (state230 c)
    (case c (else (accept 'lbracket))))
  (define (state231 c)
    (case c (else (accept 'rbracket))))
  (define (state232 c)
    (case c (else (accept 'quote))))
  (define (state233 c)
    (case c (else (accept 'backquote))))
  (define (state234 c)
    (case c (else (accept 'splicing))))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;
    ; End of state machine generated by LexGen.
    ;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;
    ; ParseGen generated the code for the strong LL(1) parser.
    ;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
(define (parse-outermost-datum)
  (case (next-token)
    ((boolean
       number
       character
       string
       id
       miscflag
       bvecstart
       vecstart
       lparen
       lbracket
       quote
       backquote
       comma
       splicing
       syntax
       quasisyntax
       unsyntax
       unsyntaxsplicing)
     (let ((ast1 (parse-datum))) (identity ast1)))
    ((eofobj) (begin (consume-token!) (makeEOF)))
    (else
     (parse-error
       '<outermost-datum>
       '(backquote
          boolean
          bvecstart
          character
          comma
          eofobj
          id
          lbracket
          lparen
          miscflag
          number
          quasisyntax
          quote
          splicing
          string
          syntax
          unsyntax
          unsyntaxsplicing
          vecstart)))))

(define (parse-datum)
  (case (next-token)
    ((unsyntaxsplicing
       unsyntax
       quasisyntax
       syntax
       splicing
       comma
       backquote
       quote
       lbracket
       lparen
       vecstart
       bvecstart)
     (let ((ast1 (parse-location)))
       (let ((ast2 (parse-structured)))
         (makeStructured ast1 ast2))))
    ((miscflag) (begin (consume-token!) (makeFlag)))
    ((id) (begin (consume-token!) (makeSym)))
    ((string) (begin (consume-token!) (makeString)))
    ((character) (begin (consume-token!) (makeChar)))
    ((number) (begin (consume-token!) (makeNum)))
    ((boolean) (begin (consume-token!) (makeBool)))
    (else
     (parse-error
       '<datum>
       '(backquote
          boolean
          bvecstart
          character
          comma
          id
          lbracket
          lparen
          miscflag
          number
          quasisyntax
          quote
          splicing
          string
          syntax
          unsyntax
          unsyntaxsplicing
          vecstart)))))

(define (parse-structured)
  (case (next-token)
    ((bvecstart)
     (let ((ast1 (parse-bytevector))) (identity ast1)))
    ((vecstart)
     (let ((ast1 (parse-vector))) (identity ast1)))
    ((lparen
       lbracket
       quote
       backquote
       comma
       splicing
       syntax
       quasisyntax
       unsyntax
       unsyntaxsplicing)
     (let ((ast1 (parse-list))) (identity ast1)))
    (else
     (parse-error
       '<structured>
       '(backquote
          bvecstart
          comma
          lbracket
          lparen
          quasisyntax
          quote
          splicing
          syntax
          unsyntax
          unsyntaxsplicing
          vecstart)))))

(define (parse-string)
  (case (next-token)
    ((string) (begin (consume-token!) (makeString)))
    (else (parse-error '<string> '(string)))))

(define (parse-symbol)
  (case (next-token)
    ((id) (begin (consume-token!) (makeSym)))
    (else (parse-error '<symbol> '(id)))))

(define (parse-list)
  (case (next-token)
    ((unsyntaxsplicing
       unsyntax
       quasisyntax
       syntax
       splicing
       comma
       backquote
       quote)
     (let ((ast1 (parse-abbreviation)))
       (identity ast1)))
    ((lbracket)
     (begin
       (consume-token!)
       (let ((ast1 (parse-blst2))) (identity ast1))))
    ((lparen)
     (begin
       (consume-token!)
       (let ((ast1 (parse-list2))) (identity ast1))))
    (else
     (parse-error
       '<list>
       '(backquote
          comma
          lbracket
          lparen
          quasisyntax
          quote
          splicing
          syntax
          unsyntax
          unsyntaxsplicing)))))

(define (parse-list2)
  (case (next-token)
    ((boolean
       number
       character
       string
       id
       miscflag
       bvecstart
       vecstart
       lparen
       lbracket
       quote
       backquote
       comma
       splicing
       syntax
       quasisyntax
       unsyntax
       unsyntaxsplicing)
     (let ((ast1 (parse-datum)))
       (let ((ast2 (parse-list3))) (cons ast1 ast2))))
    ((rparen) (begin (consume-token!) (emptyList)))
    (else
     (parse-error
       '<list2>
       '(backquote
          boolean
          bvecstart
          character
          comma
          id
          lbracket
          lparen
          miscflag
          number
          quasisyntax
          quote
          rparen
          splicing
          string
          syntax
          unsyntax
          unsyntaxsplicing
          vecstart)))))

(define (parse-list3)
  (case (next-token)
    ((rparen
       period
       unsyntaxsplicing
       unsyntax
       quasisyntax
       syntax
       splicing
       comma
       backquote
       quote
       lbracket
       lparen
       vecstart
       bvecstart
       miscflag
       id
       string
       character
       number
       boolean)
     (let ((ast1 (parse-data)))
       (let ((ast2 (parse-list4)))
         (pseudoAppend ast1 ast2))))
    (else
     (parse-error
       '<list3>
       '(backquote
          boolean
          bvecstart
          character
          comma
          id
          lbracket
          lparen
          miscflag
          number
          period
          quasisyntax
          quote
          rparen
          splicing
          string
          syntax
          unsyntax
          unsyntaxsplicing
          vecstart)))))

(define (parse-list4)
  (case (next-token)
    ((period)
     (begin
       (consume-token!)
       (let ((ast1 (parse-datum)))
         (if (eq? (next-token) 'rparen)
             (begin (consume-token!) (identity ast1))
             (parse-error '<list4> '(rparen))))))
    ((rparen) (begin (consume-token!) (emptyList)))
    (else (parse-error '<list4> '(period rparen)))))

(define (parse-blst2)
  (case (next-token)
    ((boolean
       number
       character
       string
       id
       miscflag
       bvecstart
       vecstart
       lparen
       lbracket
       quote
       backquote
       comma
       splicing
       syntax
       quasisyntax
       unsyntax
       unsyntaxsplicing)
     (let ((ast1 (parse-datum)))
       (let ((ast2 (parse-blst3))) (cons ast1 ast2))))
    ((rbracket) (begin (consume-token!) (emptyList)))
    (else
     (parse-error
       '<blst2>
       '(backquote
          boolean
          bvecstart
          character
          comma
          id
          lbracket
          lparen
          miscflag
          number
          quasisyntax
          quote
          rbracket
          splicing
          string
          syntax
          unsyntax
          unsyntaxsplicing
          vecstart)))))

(define (parse-blst3)
  (case (next-token)
    ((rbracket
       period
       unsyntaxsplicing
       unsyntax
       quasisyntax
       syntax
       splicing
       comma
       backquote
       quote
       lbracket
       lparen
       vecstart
       bvecstart
       miscflag
       id
       string
       character
       number
       boolean)
     (let ((ast1 (parse-data)))
       (let ((ast2 (parse-blst4)))
         (pseudoAppend ast1 ast2))))
    (else
     (parse-error
       '<blst3>
       '(backquote
          boolean
          bvecstart
          character
          comma
          id
          lbracket
          lparen
          miscflag
          number
          period
          quasisyntax
          quote
          rbracket
          splicing
          string
          syntax
          unsyntax
          unsyntaxsplicing
          vecstart)))))

(define (parse-blst4)
  (case (next-token)
    ((period)
     (begin
       (consume-token!)
       (let ((ast1 (parse-datum)))
         (if (eq? (next-token) 'rbracket)
             (begin (consume-token!) (identity ast1))
             (parse-error '<blst4> '(rbracket))))))
    ((rbracket) (begin (consume-token!) (emptyList)))
    (else (parse-error '<blst4> '(period rbracket)))))

(define (parse-abbreviation)
  (case (next-token)
    ((quote backquote
            comma
            splicing
            syntax
            quasisyntax
            unsyntax
            unsyntaxsplicing)
     (let ((ast1 (parse-abbrev-prefix)))
       (let ((ast2 (parse-datum))) (list ast1 ast2))))
    (else
     (parse-error
       '<abbreviation>
       '(backquote
          comma
          quasisyntax
          quote
          splicing
          syntax
          unsyntax
          unsyntaxsplicing)))))

(define (parse-abbrev-prefix)
  (case (next-token)
    ((unsyntaxsplicing)
     (begin (consume-token!) (symUnsyntax-splicing)))
    ((unsyntax)
     (begin (consume-token!) (symUnsyntax)))
    ((quasisyntax)
     (begin (consume-token!) (symQuasisyntax)))
    ((syntax) (begin (consume-token!) (symSyntax)))
    ((splicing)
     (begin (consume-token!) (symSplicing)))
    ((comma) (begin (consume-token!) (symUnquote)))
    ((backquote)
     (begin (consume-token!) (symBackquote)))
    ((quote) (begin (consume-token!) (symQuote)))
    (else
     (parse-error
       '<abbrev-prefix>
       '(backquote
          comma
          quasisyntax
          quote
          splicing
          syntax
          unsyntax
          unsyntaxsplicing)))))

(define (parse-vector)
  (case (next-token)
    ((vecstart)
     (begin
       (consume-token!)
       (let ((ast1 (parse-data)))
         (if (eq? (next-token) 'rparen)
             (begin (consume-token!) (list2vector ast1))
             (parse-error '<vector> '(rparen))))))
    (else (parse-error '<vector> '(vecstart)))))

(define (parse-bytevector)
  (case (next-token)
    ((bvecstart)
     (begin
       (consume-token!)
       (let ((ast1 (parse-octets)))
         (if (eq? (next-token) 'rparen)
             (begin (consume-token!) (list2bytevector ast1))
             (parse-error '<bytevector> '(rparen))))))
    (else (parse-error '<bytevector> '(bvecstart)))))

(define (parse-data)
  (case (next-token)
    ((boolean
       number
       character
       string
       id
       miscflag
       bvecstart
       vecstart
       lparen
       lbracket
       quote
       backquote
       comma
       splicing
       syntax
       quasisyntax
       unsyntax
       unsyntaxsplicing)
     (let ((ast1 (parse-datum)))
       (let ((ast2 (parse-data))) (cons ast1 ast2))))
    ((rparen period rbracket) (emptyList))
    (else
     (parse-error
       '<data>
       '(backquote
          boolean
          bvecstart
          character
          comma
          id
          lbracket
          lparen
          miscflag
          number
          period
          quasisyntax
          quote
          rbracket
          rparen
          splicing
          string
          syntax
          unsyntax
          unsyntaxsplicing
          vecstart)))))

(define (parse-octets)
  (case (next-token)
    ((number)
     (let ((ast1 (parse-octet)))
       (let ((ast2 (parse-octets))) (cons ast1 ast2))))
    ((rparen) (emptyList))
    (else (parse-error '<octets> '(number rparen)))))

(define (parse-octet)
  (case (next-token)
    ((number) (begin (consume-token!) (makeOctet)))
    (else (parse-error '<octet> '(number)))))

(define (parse-location)
  (case (next-token)
    ((unsyntaxsplicing
       unsyntax
       quasisyntax
       syntax
       splicing
       comma
       backquote
       quote
       lbracket
       lparen
       vecstart
       bvecstart)
     (sourceLocation))
    (else
     (parse-error
       '<location>
       '(backquote
          bvecstart
          comma
          lbracket
          lparen
          quasisyntax
          quote
          splicing
          syntax
          unsyntax
          unsyntaxsplicing
          vecstart)))))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;
    ; End of LL(1) parser generated by ParseGen.
    ;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;
    ; Lexical analyzer.
    ;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
    ; next-token and consume-token! are called by the parser.
  
    ; Returns the current token.
  
    (define (next-token)
      (if nextTokenIsReady
          kindOfNextToken
          (begin (set! string_accumulator_length 0)
                 (scanner0))))
  
    ; Consumes the current token.
  
    (define (consume-token!)
      (set! nextTokenIsReady #f))
  
    ; Called by the lexical analyzer's state machine.
  
    (define (scannerError msg)
      (define msgtxt
        (cond ((= msg errLongToken)
               "Amazingly long token")
              ((= msg errIncompleteToken)
               "Incomplete or illegal token")
              ((= msg errIllegalHexEscape)
               "Illegal hex escape")
              ((= msg errIllegalNamedChar)
               "Illegal character syntax")
              ((= msg errIllegalString)
               "Illegal string syntax")
              ((= msg errIllegalSymbol)
               "Illegal symbol syntax")
              ((= msg errNoDelimiter)
               "Missing delimiter")
              ((= msg errSquareBracket)
               "Square brackets are disabled")
              ((= msg errLexGenBug)
               "Bug in lexical analyzer (generated)")
              (else "Bug in lexical analyzer")))
      (let* ((c (scanChar))
             (next (if (char? c) (string c) ""))
             (msgtxt (string-append msgtxt
                                    ": "
                                    (substring string_accumulator
                                               0
                                               string_accumulator_length)
                                    next)))

        ; must avoid infinite loop on current input port

        (consumeChar)
        (error 'get-datum
               (string-append "Lexical Error: " msgtxt " ")
               filename))
      (next-token))
  
    ; Accepts a token of the given kind, returning that kind.
    ;
    ; For some kinds of tokens, a value for the token must also
    ; be recorded in tokenValue.  Most of those tokens must be
    ; followed by a delimiter.
    ;
    ; Some magical tokens require special processing.
  
    (define (accept t)
      (case t

       ((comment)
        ; The token is #|, which starts a nested comment.
        (scan-nested-comment)
        (next-token))

       ((commentdatum)
        ; The token is #; so parse and ignore the next datum.
        (parse-datum)
        (next-token))

       ((id boolean number character string miscflag period)

        (set! tokenValue
              (substring string_accumulator
                         0 string_accumulator_length))

        (cond ((and (eq? t 'miscflag)
                    (string=? tokenValue "#!r6rs"))
               (next-token))

              ((or (delimiter? (scanChar))
                   (eq? t 'string))
               (set! kindOfNextToken t)
               (set! nextTokenIsReady #t)
               t)

              (else
               (scannerError errNoDelimiter))))

       (else
        (set! kindOfNextToken t)
        (set! nextTokenIsReady #t)
        t)))

    ; Having seen a #| token, scans and discards the entire comment.

    (define (scan-nested-comment)
      (define (loop depth)
        (let ((c (scanChar)))
          (cond ((= depth 0) #t)
                ((eof-object? c)
                 (scannerError errIncompleteToken))
                ((char=? c #\#)
                 (consumeChar)
                 (if (char=? (scanChar) #\|)
                     (begin (consumeChar) (loop (+ depth 1)))
                     (loop depth)))
                ((char=? c #\|)
                 (consumeChar)
                 (if (char=? (scanChar) #\#)
                     (begin (consumeChar) (loop (- depth 1)))
                     (loop depth)))
                (else
                 (consumeChar)
                 (loop depth)))))
      (loop 1))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;
    ; Character i/o, so to speak.
    ; Uses the input-port as input.
    ;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
    (define (scanChar)
      (peek))

    ; Consumes the current character.  Returns unspecified values.
  
    (define (consumeChar)
      (if (< string_accumulator_length (string-length string_accumulator))
          (let ((c (input)))
            (if (char? c)
                (begin
                 (string-set! string_accumulator
                              string_accumulator_length
                              c)
                 (set! string_accumulator_length
                       (+ string_accumulator_length 1)))))
          (begin (expand-accumulator) (consumeChar))))

    ; Doubles the size of string_accumulator while
    ; preserving its contents.

    (define (expand-accumulator)
      (let* ((n (string-length string_accumulator))
             (new (make-string (* 2 n))))
        (do ((i 0 (+ i 1)))
            ((= i n))
          (string-set! new i (string-ref string_accumulator i)))
        (set! string_accumulator new)))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;
    ; Miscellaneous utility routines.
    ;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; Determines whether its argument is a <delimiter>.

    (define (delimiter? c)
      (case c
       ((#\( #\) #\[ #\] #\" #\; #\#)
        #t)
       (else
        (or (not (char? c))
            (char-whitespace? c)))))         

    ; Given the integer parsed from a hex escape,
    ; returns the corresponding Unicode character.

    (define (checked-integer->char n)
      (if (or (< n #xd800)
              (<= #xe000 n #x10ffff))
          (integer->char n)
          (scannerError errIllegalHexEscape)))

    ; Given a string and the index at the beginning of nonempty
    ; sequence of hexadecimal characters followed by a semicolon,
    ; returns two values:
    ;     the numerical value of the hex characters
    ;     the index following the semicolon

    (define (hex-escape s i)
      (let ((n (string-length s)))
        (define (loop i val)
          (if (>= i n)
              (scannerError errIllegalHexEscape)
              (let ((c (string-ref s i)))
                (case c
                 ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
                  (loop (+ i 1)
                        (+ (* 16 val)
                           (- (char->integer c) (char->integer #\0)))))
                 ((#\a #\b #\c #\d #\e #\f)
                  (loop (+ i 1)
                        (+ (* 16 val)
                           10
                           (- (char->integer c) (char->integer #\a)))))
                 ((#\A #\B #\C #\D #\E #\F)
                  (loop (+ i 1)
                        (+ (* 16 val)
                           10
                           (- (char->integer c) (char->integer #\A)))))
                 ((#\;)
                  (values val (+ i 1)))
                 (else (scannerError errIllegalHexEscape))))))
        (loop i 0)))
  
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;
    ; Action procedures called by the parser.
    ;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    ; Hook for recording source locations.
    ; Called by some action routines.

    (define (record-source-location x loc) x)

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    (define (emptyList) '())
  
    (define (identity x) x)

    (define (list2bytevector octets) (u8-list->bytevector octets))

    (define (list2vector vals) (list->vector vals))
  
    (define (makeBool)
      (let ((x (case (string-ref tokenValue 1)
                ((#\t #\T) #t)
                ((#\f #\F) #f)
                (else (scannerError errBug)))))
        (record-source-location x locationStart)))
  
    (define (makeChar)
      (let* ((n (string-length tokenValue))
             (x (cond ((= n 3)
                       (string-ref tokenValue 2))
                      ((char=? #\x (string-ref tokenValue 2))
                       (checked-integer->char
                        (string->number (substring tokenValue 3 n) 16)))
                      (else
                       (let* ((s (substring tokenValue 2 n))
                              #| ignored.
                              (s (if (port-folds-case? input-port)
                                     (string-foldcase s)
                                     s))
                              |#
                              (sym (string->symbol s)))
                         (case sym
                          ((nul)               #\nul)
                          ((alarm)             char:alarm)
                          ((backspace)         #\backspace)
                          ((tab)               #\tab)
                          ((linefeed newline)  #\linefeed)
                          ((vtab)              #\vtab)
                          ((page)              #\page)
                          ((return)            #\return)
                          ((esc)               char:esc)
                          ((space)             #\space)
                          ((delete)            char:delete)
                          (else
                           (scannerError errIllegalNamedChar))))))))
        (record-source-location x locationStart)))

    (define (makeEOF) (eof-object))

    (define (makeFlag)

      ; The draft R6RS allows implementation-specific extensions
      ; of the form #!..., which are processed here.
      ; Note that the #!r6rs flag is a comment, handled by accept,
      ; so that flag will never be seen here.

      (accept 'miscflag)
      (parse-error '<miscflag> '(miscflag)))
  
    (define (makeNum)
      (let ((x (string->number tokenValue)))
        (if x
            (record-source-location x locationStart)
            (begin (accept 'number)
                   (parse-error '<number> '(number))))))
  
    (define (makeOctet)
      (let ((n (string->number tokenValue)))
        (if (and (exact? n) (integer? n) (<= 0 n 255))
            (record-source-location n locationStart)
            (begin (accept 'octet)
                   (parse-error '<octet> '(octet))))))
  
    (define (makeString)

      ; Must strip off outer double quotes and deal with escapes.
      ;
      ; i is the next index into tokenValue
      ; n is the exclusive upper bound for i
      ; newstring is a string that might become the result
      ; j is the next index into newstring

      (define (loop i n newstring j)
        (if (>= i n)
            (if (= j (string-length newstring))
                newstring
                (substring newstring 0 j))
            (let ((c (string-ref tokenValue i)))
              (cond ((or (char=? c #\return)
                         (char=? c #\linefeed)
                         (char=? c char:nel)
                         (char=? c char:ls))
                     (string-set! newstring j #\linefeed)
                     (let* ((i+1 (+ i 1))
                            (i+1 (if (and (char=? c #\return)
                                          (< i+1 n))
                                     (let ((c2 (string-ref tokenValue i+1)))
                                       (if (or (char=? c2 #\linefeed)
                                               (char=? c2 char:nel))
                                           (+ i 2)
                                           i+1))
                                     i+1)))
                       (loop i+1 n newstring (+ j 1))))
                    ((char=? c #\\)
                     (if (< (+ i 1) n)
                         (let ((c2 (string-ref tokenValue (+ i 1))))
                           (case c2
                            ((#\a)
                             (string-set! newstring j char:alarm)
                             (loop (+ i 2) n newstring (+ j 1)))
                            ((#\b)
                             (string-set! newstring j #\backspace)
                             (loop (+ i 2) n newstring (+ j 1)))
                            ((#\t)
                             (string-set! newstring j #\tab)
                             (loop (+ i 2) n newstring (+ j 1)))
                            ((#\n)
                             (string-set! newstring j #\linefeed)
                             (loop (+ i 2) n newstring (+ j 1)))
                            ((#\v)
                             (string-set! newstring j #\vtab)
                             (loop (+ i 2) n newstring (+ j 1)))
                            ((#\f)
                             (string-set! newstring j #\page)
                             (loop (+ i 2) n newstring (+ j 1)))
                            ((#\r)
                             (string-set! newstring j #\return)
                             (loop (+ i 2) n newstring (+ j 1)))
                            ((#\" #\\)
                             (string-set! newstring j c2)
                             (loop (+ i 2) n newstring (+ j 1)))
                            ((#\x)
                             (call-with-values
                              (lambda () (hex-escape tokenValue (+ i 2)))
                              (lambda (sv i)
                                (string-set! newstring
                                             j
                                             (checked-integer->char sv))
                                (loop i n newstring (+ j 1)))))
                            (else
                             (ignore-escaped-line-ending (+ i 1)
                                                         n newstring j #f))))
                     (scannerError errIllegalString)))
                    (else
                     (string-set! newstring j c)
                     (loop (+ i 1) n newstring (+ j 1)))))))

      ; Ignores <intraline whitespace>* <line ending> <intraline whitespace>*
      ; after? is true iff the <line ending> has already been ignored.
      ; The other arguments are the same as for loop above.

      (define (ignore-escaped-line-ending i n newstring j after?)
        (cond ((< i n)
               (let ((c (string-ref tokenValue i)))
                 (cond ((or (char=? c #\tab)
                            (eq? 'Zs (char-general-category c)))
                        (ignore-escaped-line-ending (+ i 1)
                                                    n newstring j after?))
                       (after?
                        (loop i n newstring j))
                       ((or (char=? c #\return)
                            (char=? c #\linefeed)
                            (char=? c char:nel)
                            (char=? c char:ls))
                        (let* ((i+1 (+ i 1))
                               (i+1 (if (and (char=? c #\return)
                                             (< i+1 n))
                                        (let ((c2 (string-ref
                                                   tokenValue i+1)))
                                          (if (or (char=? c2 #\linefeed)
                                                  (char=? c2 char:nel))
                                              (+ i 2)
                                              i+1))
                                        i+1)))
                          (ignore-escaped-line-ending i+1 n newstring j #t)))
                       (else
                        (scannerError errIllegalString)))))
              (after?
               (loop i n newstring j))
              (else
               (scannerError errIllegalString))))

      (let* ((n (string-length tokenValue))
             (s (loop 1 (- n 1) (make-string (- n 2)) 0)))
        (record-source-location s locationStart)))

    (define (makeStructured loc0 x)
      (record-source-location x loc0))

    ; Several Larceny-specific extensions are handled here:
    ;     leading . or @ or +: or -:
    ;     vertical bars at beginning and end (which quote the interior)
    ;     vertical bars (embedded, which do not quote)
    ;     backslashes for other than hex escapes
    ;         (note: they disable *all* case folding)
    ;     MzScheme randomness
    ;     several peculiar identifiers

    (define (makeSym)
      (let ((n (string-length tokenValue)))
        ;; YUNI: actually returns identifier-object
        (define (return sym)
          (make-identifier sym #f current-position))
        (define (loop i)
          (if (= i n)
              (return (string->symbol tokenValue))
              (let ((c (string-ref tokenValue i)))
                (cond ((or (char=? c #\\)
                           (char=? c #\#))
                       (slow-loop i
                                  (reverse
                                   (string->list (substring tokenValue 0 i)))))
                      (else
                       (loop (+ i 1)))))))
        (define (slow-loop i chars)
          (if (= i n)
              (return (string->symbol (list->string (reverse chars))))
              (let ((c (string-ref tokenValue i)))
                (cond ((char=? c #\\)
                       (cond ((and (< (+ i 1) n)
                                   (char=? (string-ref tokenValue (+ i 1))
                                           #\x))
                              (call-with-values
                               (lambda () (hex-escape tokenValue (+ i 2)))
                               (lambda (sv i)
                                 (slow-loop i
                                            (cons (checked-integer->char sv)
                                                  chars)))))
                             (else
                              (scannerError errIllegalSymbol))))
                      (else (slow-loop (+ i 1) (cons c chars)))))))
        (loop 0)))

    ; Like append, but allows the last argument to be a non-list.
  
    (define (pseudoAppend vals terminus)
      (if (null? vals)
          terminus
          (cons (car vals)
                (pseudoAppend (cdr vals) terminus))))

    ; Hook for associating source locations with tokens.

    (define (sourceLocation) 0)

    (define (symBackquote) 'quasiquote)
    (define (symQuasisyntax) 'quasisyntax)
    (define (symQuote) 'quote)
    (define (symSplicing) 'unquote-splicing)
    (define (symSyntax) 'syntax)
    (define (symUnquote) 'unquote)
    (define (symUnsyntax) 'unsyntax)
    (define (symUnsyntax-splicing) 'unsyntax-splicing)
  
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;
    ; Error procedure called by the parser.
    ;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
    (define (parse-error nonterminal expected-terminals)
      (let* ((culprit (next-token))
             (culprit-as-string (symbol->string culprit))
             (culprit-as-string
              (if (memq culprit expected-terminals)
                  (string-append "illegal " culprit-as-string)
                  culprit-as-string))
             (msg (string-append
                   "Syntax error while parsing "
                   (symbol->string nonterminal)
                   (string #\newline)
                   "  Encountered "
                   culprit-as-string
                   " while expecting "
                   (case nonterminal
                    ((<datum> <outermost-datum> <data>)
                     "a datum")
                    (else
                     (string-append
                      (string #\newline)
                      "  "
                      (apply string-append
                             (map (lambda (terminal)
                                    (string-append " "
                                                   (symbol->string terminal)))
                                  expected-terminals)))))
                   (string #\newline))))
        (error 'get-datum msg filename)))

    ; The list of tokens that can start a datum in R6RS mode.

    (define datum-starters
      '(backquote
        boolean
        bvecstart
        character
        comma
        id
        lbracket
        lparen
        miscflag
        number
        quasisyntax
        quote
        splicing
        string
        syntax
        unsyntax
        unsyntaxsplicing
        vecstart))
  
    (define (mainloop)
      (parse-outermost-datum))

    (define (output cur)
      (let ((obj (mainloop)))
        (if (eof-object? obj)
          (reverse cur)
          (output (cons obj cur)))))
    (output '()) ))

; eof
)
