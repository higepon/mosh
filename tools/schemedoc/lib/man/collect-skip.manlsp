(((title . "Reference Manual of Buffered Input Streams") (author (ast "span" ("Kurt Nørmark" #t " " #t (char-ref copy)) () double xhtml10-transitional ()) #t "normark@cs.aau.dk") (affiliation "Department of Computer Science," #t "Aalborg University," #t "Denmark.") (abstract . " This library supports buffered input stream. A buffered input stream is convenient for various kinds of parsing tasks. <p> It is assumed that the variable ip references an open input port, or a string. The assignment of ip must be done exernally to this library, and after the library is loaded. If ip references an open input stream (made by the Scheme function open-input-file, for instance) input is read from that port. If ip is string, the variable pstring-ip-pointer is used as a pointer into the string.<p> The functions in section one are generic, low-level reading functions that either read from the open input port, or from a string (at the location  determined by the variable pstring-ip-pointer). The functions in section two are the basic reading and peeking functions.  In section three a number of convenient collection and skipping functions are provided for.<p> This library has been developed as part of an SGML/XML Document Type Definition (DTD) parser, but it is useful in many other parsing situations. There exists <a href=\"http://www.cs.auc.dk/~normark/scheme/tools/dtd-parser/doc/html/index.html\">som early internal documentation</a> of the DTD parser (on the www.cs.auc.dk site) and as such also of some aspects of the functions in this library.<p> In earlier versions of LAML, this library was called 'the text collection and skipping library'. ") (scheme-source-file . "/user/normark/scheme/lib/collect-skip.scm/") (laml-resource . "true") (documentation-commenting-style . not-provided) (default-attribute-explanation . not-provided) (source-destination-delta . not-provided) (css-prestylesheet . "compact") (css-stylesheet . "argentina") (css-stylesheet-copying . "true") (make-dtd-manual-template . not-provided) (keep-syntactical-comment-file . not-provided) (manual-destination-name . not-provided) (mirror-names-defined . not-provided) (mirror-name-prefix . not-provided) (attribute-sorting . not-provided) (scheme-source-linking . "true")) ((kind "manual-section") (section-title "Low-level, generic input functions.") (section-body "The functions in this section reads from either an input port, or from a string.")) ((cross-references (reference "Scheme source file" "generic-read-char" "collect-skip-ep/collect-skip-1.html#generic-read-char")) (kind "manual-page") (description "Reads a single character from ip, and advances the input pointer. ") (title "generic-read-char") (form (generic-read-char ip))) ((cross-references (reference "Scheme source file" "generic-eof-object?" "collect-skip-ep/collect-skip-1.html#generic-eof-object?")) (kind "manual-page") (description "Is x the designated end-of-file value relative to the implicitly given input port ip. ") (title "generic-eof-object?") (form (generic-eof-object? x))) ((kind "manual-section") (section-title "Look ahead buffer and queue.") (section-body "The functions in this section manipulates a look ahead queue, which is in between the input port ip and the applications. Via this buffer it is possible to implement look ahead in the input port.<p> Imagine an input buffer of (actual) size n: <pre> c1 c2 c3 ... cn </pre> When characters are read from the input stream, they enter to the right (the peek end). When characters are read by an application they are taken from the left (the read end). Thus, cn is the last character read from the input port (or from the input string); This is done by peek-a-char. c1 is the next char to leave the buffer, and to be read by the client application; This will be done by read-a-char.<p> A few words about terminology in relation to R4RS or R5RS. The Scheme procedure read-char corresponds roughtly to read-a-char; The former always reads a character from an input port; The latter reads from an input stream via the buffer; Only if the buffer is empty, a character is read from the port or string. The proper Scheme function peek-char returns the next char from the input port, without updating the 'input pointer'. The function peek-a-char of this library is different, because it reads a character from the file and puts it into the buffer. This use of terminology is unfortunate, and it may be confusing for some readers.")) ((cross-references (reference "Scheme source file" "max-look-ahead" "collect-skip-ep/collect-skip-1.html#max-look-ahead")) (kind "manual-page") (description "The length of the cyclic look ahead buffer. Predefined to 20000 characters. A constant. ") (title "max-look-ahead") (form max-look-ahead)) ((cross-references (reference "Scheme source file" "reset-look-ahead-buffer" "collect-skip-ep/collect-skip-1.html#reset-look-ahead-buffer")) (kind "manual-page") (description "Reset the look ahead buffer. You should always call this function after you have re-assigned ip to a new input stream. ") (title "reset-look-ahead-buffer") (form (reset-look-ahead-buffer))) ((cross-references (reference "Scheme source file" "peek-a-char" "collect-skip-ep/collect-skip-1.html#peek-a-char")) (kind "manual-page") (description "Peek a character from the input port, but queues it for subsequent reading at \"the peek end\". This function always reads one character via generic-read-char, and puts in into the \"peek end\" of the buffer. ") (title "peek-a-char") (form (peek-a-char))) ((kind "manual-page") (description "Peeks n charcters, by n calls of peek-a-char. In other words, the buffer is extended with n characters read from the input stream. ") (title "peek-chars") (form (peek-chars n)) (cross-references (reference "Scheme source file" "peek-chars" "collect-skip-ep/collect-skip-1.html#peek-chars") (internal-references "relies on" "peek-a-char"))) ((cross-references (reference "Scheme source file" "read-a-char" "collect-skip-ep/collect-skip-1.html#read-a-char")) (kind "manual-page") (description "Read from the the look ahead buffer. Only if this buffer is empty, read from the port. Reads from \"the read end\" of the queue. In case the buffer is non-empty, this procedure takes a character out of the buffer in the \"read end\". In any case, it advances the implicit input pointer of the input stream. ") (title "read-a-char") (form (read-a-char))) ((cross-references (reference "Scheme source file" "read-a-string" "collect-skip-ep/collect-skip-1.html#read-a-string")) (kind "manual-page") (description "Read and return a string of length n by means of repeated activations of read-a-char. Takes eof into account such that a string shorter than n can be returned. ") (title "read-a-string") (form (read-a-string n))) ((cross-references (reference "Scheme source file" "look-ahead-prefix" "collect-skip-ep/collect-skip-1.html#look-ahead-prefix")) (kind "manual-page") (description "Return a string of length lgt from the \"read end\" of the buffer. A proper function. ") (pre-condition "lgt cannot be larger than the number of characters in the buffer.") (title "look-ahead-prefix") (form (look-ahead-prefix lgt))) ((cross-references (reference "Scheme source file" "max-look-ahead-prefix" "collect-skip-ep/collect-skip-1.html#max-look-ahead-prefix")) (kind "manual-page") (description "Return the entire look ahead queue as a string. A proper function. ") (title "max-look-ahead-prefix") (form (max-look-ahead-prefix))) ((cross-references (reference "Scheme source file" "look-ahead-char" "collect-skip-ep/collect-skip-1.html#look-ahead-char")) (kind "manual-page") (description "Return the first character from the \"read end\" of the buffer. A proper function. ") (pre-condition "The buffer is not empty.") (title "look-ahead-char") (form (look-ahead-char))) ((cross-references (reference "Scheme source file" "match-look-ahead?" "collect-skip-ep/collect-skip-1.html#match-look-ahead?")) (kind "manual-page") (description "Return whether the buffer matches the string str. Matching is done by the function equal? A proper function. ") (title "match-look-ahead?") (form (match-look-ahead? str))) ((kind "manual-page") (description "Make sure that there is at least n characters in the buffer. If there are less than n characters, ented a sufficient number of characters with peek-chars. ") (title "ensure-look-ahead") (form (ensure-look-ahead n)) (cross-references (reference "Scheme source file" "ensure-look-ahead" "collect-skip-ep/collect-skip-1.html#ensure-look-ahead") (internal-references "relies on" "peek-chars"))) ((cross-references (reference "Scheme source file" "put-back-a-char-write-end" "collect-skip-ep/collect-skip-1.html#put-back-a-char-write-end")) (kind "manual-page") (description "Put ch into the \"peek end\" of buffer (where peek-a-char operates). ") (title "put-back-a-char-write-end") (form (put-back-a-char-write-end ch))) ((cross-references (reference "Scheme source file" "put-back-a-char-read-end" "collect-skip-ep/collect-skip-1.html#put-back-a-char-read-end")) (kind "manual-page") (description "Put ch into the \"read end\" buffer (where read-a-char operates). ") (title "put-back-a-char-read-end") (form (put-back-a-char-read-end ch))) ((cross-references (reference "Scheme source file" "put-back-a-string" "collect-skip-ep/collect-skip-1.html#put-back-a-string")) (kind "manual-page") (description "Put str back into the buffer. The second parameter which-end controls whether to put back in read end or write end (equivalent to peek end). Possible values of which end are the symbols read-end or write-end. ") (title "put-back-a-string") (form (put-back-a-string str which-end))) ((cross-references (reference "Scheme source file" "advance-look-ahead" "collect-skip-ep/collect-skip-1.html#advance-look-ahead")) (kind "manual-page") (description "Provided that there is at least n characters in the buffer, advance next-read with n positions. Hereby n queued characters are skipped from the buffer at the \"read end\". ") (title "advance-look-ahead") (form (advance-look-ahead n))) ((kind "manual-section") (section-title "Collection and skipping functions.") (section-body "This section contains a number of higher level collection and skipping functions. These functions use the funtions from the previous section. The functions in this section are the most important of this library.")) ((cross-references (reference "Scheme source file" "collect-until" "collect-skip-ep/collect-skip-1.html#collect-until")) (kind "manual-page") (description "Read and collect a string from the input, controlled by a predicate. The collection stops when the predicate p holds on the character read. The last read character (the first character on which p holds) is left as the oldest character in the queue. ") (title "collect-until") (form (collect-until p))) ((cross-references (reference "Scheme source file" "collect-balanced-until" "collect-skip-ep/collect-skip-1.html#collect-balanced-until")) (kind "manual-page") (description "This collection procedure returns a balanced collection given two char predicates. Return the string collected from the input port ip. The collection stops when the predicate char-pred-2 holds on the character read. However, if char-pred-1 becomes true it has to be matched by char-pred-2 without causing a termination of the collection. The last read character (the first character on which char-pred-2 holds) is processed by this function. As a precondition assume that if char-pred-1 holds then char-pred-2 does not hold, and vice versa. ") (title "collect-balanced-until") (form (collect-balanced-until char-pred-1 char-pred-2))) ((cross-references (reference "Scheme source file" "skip-while" "collect-skip-ep/collect-skip-1.html#skip-while")) (kind "manual-page") (description "Skip characters while p holds. The first character on which p fails is left as the oldest character in the queue. The predicate does not hold if end of file. ") (title "skip-while") (form (skip-while p))) ((cross-references (reference "Scheme source file" "skip-string" "collect-skip-ep/collect-skip-1.html#skip-string")) (kind "manual-page") (description "Assume that str is just in front of us. Skip through it. If str is not in front of us, a fatal error occurs with if-not-message as error message. ") (title "skip-string") (form (skip-string str if-not-message))) ((cross-references (reference "Scheme source file" "skip-until-string" "collect-skip-ep/collect-skip-1.html#skip-until-string")) (kind "manual-page") (description "Skip characters until str is encountered. If inclusive, also skip str. It is assumed as a precondition that the length of str is at least one. ") (title "skip-until-string") (form (skip-until-string str . inclusive))) ((cross-references (reference "Scheme source file" "collect-until-string" "collect-skip-ep/collect-skip-1.html#collect-until-string")) (kind "manual-page") (description "Collect characters until str is encountered. If inclusive, also collect str. It is assumed as a precondition that the length of str is at least one. ") (title "collect-until-string") (form (collect-until-string str . inclusive))) ((kind "manual-section") (section-title "Useful predicates for skipping and collecting.") (section-body "")) ((cross-references (reference "Scheme source file" "is-white-space?" "collect-skip-ep/collect-skip-1.html#is-white-space?")) (kind "manual-page") (description "Is ch a white space character? ") (title "is-white-space?") (form (is-white-space? ch))) ((cross-references (reference "Scheme source file" "end-of-line?" "collect-skip-ep/collect-skip-1.html#end-of-line?")) (kind "manual-page") (description "Is ch an end of line charcter? ") (title "end-of-line?") (form (end-of-line? ch))) ((cross-references (reference "Scheme source file" "eof?" "collect-skip-ep/collect-skip-1.html#eof?")) (kind "manual-page") (description "Is ch an end of file character? ") (title "eof?") (form (eof? ch))) ((cross-references (reference "Scheme source file" "char-predicate" "collect-skip-ep/collect-skip-1.html#char-predicate")) (kind "manual-page") (description "Return a predicate functions which matches the character ch. A higher order function. ") (title "char-predicate") (form (char-predicate ch))))